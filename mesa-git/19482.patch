From ae8faf8de844164a7bf1dd2304c9e8c919796642 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@collabora.com>
Date: Tue, 15 Nov 2022 11:16:15 -0500
Subject: [PATCH 01/14] panfrost: Fix reference counting with batch->resources

Refactor accesses to batch->resources to happen through safe helpers
that update the appropriate bookkeeping. This makes it obvious that (in
particular) reference counts are updated when they should be.

The functional change is that we are now correctly unreferencing
resources during shadowing, fixing a leak of shadowed resources.

Closes: #7362
Fixes: 2d8f28df731 ("panfrost: Replace resource shadowing flush")
Signed-off-by: Alyssa Rosenzweig <alyssa@collabora.com>
Reported-by: Mastodon, apparently
---
 src/gallium/drivers/panfrost/pan_job.c | 116 ++++++++++++++++---------
 src/gallium/drivers/panfrost/pan_job.h |   2 +-
 2 files changed, 74 insertions(+), 44 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_job.c b/src/gallium/drivers/panfrost/pan_job.c
index 5e8176469369..27be0ee10ed6 100644
--- a/src/gallium/drivers/panfrost/pan_job.c
+++ b/src/gallium/drivers/panfrost/pan_job.c
@@ -99,6 +99,74 @@ panfrost_batch_init(struct panfrost_context *ctx,
         screen->vtbl.init_batch(batch);
 }
 
+/*
+ * Safe helpers for manipulating batch->resources follow. In addition to
+ * wrapping the underlying set operations, these update the required
+ * bookkeeping for resource tracking and reference counting.
+ */
+static bool
+panfrost_batch_uses_resource(struct panfrost_batch *batch,
+                             struct panfrost_resource *rsrc)
+{
+        return _mesa_set_search(batch->resources, rsrc) != NULL;
+}
+
+static void
+panfrost_batch_add_resource(struct panfrost_batch *batch,
+                            struct panfrost_resource *rsrc)
+{
+        bool found = false;
+        _mesa_set_search_or_add(batch->resources, rsrc, &found);
+
+        if (!found) {
+                /* Cache number of batches accessing a resource */
+                rsrc->track.nr_users++;
+
+                /* Reference the resource on the batch */
+                pipe_reference(NULL, &rsrc->base.reference);
+        }
+}
+
+static void
+panfrost_batch_remove_resource_internal(struct panfrost_context *ctx,
+                                        struct panfrost_resource *rsrc)
+{
+        struct hash_entry *writer = _mesa_hash_table_search(ctx->writers, rsrc);
+        if (writer) {
+                _mesa_hash_table_remove(ctx->writers, writer);
+                rsrc->track.nr_writers--;
+        }
+
+        rsrc->track.nr_users--;
+        pipe_resource_reference((struct pipe_resource **) &rsrc, NULL);
+}
+
+static void
+panfrost_batch_remove_resource_if_present(struct panfrost_context *ctx,
+                                          struct panfrost_batch *batch,
+                                          struct panfrost_resource *rsrc)
+{
+        struct set_entry *ent = _mesa_set_search(batch->resources, rsrc);
+
+        if (ent != NULL) {
+                panfrost_batch_remove_resource_internal(ctx, rsrc);
+                _mesa_set_remove(batch->resources, ent);
+        }
+}
+
+static void
+panfrost_batch_destroy_resources(struct panfrost_context *ctx,
+                                 struct panfrost_batch *batch)
+{
+        set_foreach(batch->resources, entry) {
+                struct panfrost_resource *rsrc = (void *) entry->key;
+
+                panfrost_batch_remove_resource_internal(ctx, rsrc);
+        }
+
+        _mesa_set_destroy(batch->resources, NULL);
+}
+
 static void
 panfrost_batch_cleanup(struct panfrost_context *ctx, struct panfrost_batch *batch)
 {
@@ -122,20 +190,7 @@ panfrost_batch_cleanup(struct panfrost_context *ctx, struct panfrost_batch *batc
                 panfrost_bo_unreference(bo);
         }
 
-        set_foreach(batch->resources, entry) {
-                struct panfrost_resource *rsrc = (void *) entry->key;
-
-                if (_mesa_hash_table_search(ctx->writers, rsrc)) {
-                        _mesa_hash_table_remove_key(ctx->writers, rsrc);
-                        rsrc->track.nr_writers--;
-                }
-
-                rsrc->track.nr_users--;
-
-                pipe_resource_reference((struct pipe_resource **) &rsrc, NULL);
-        }
-
-        _mesa_set_destroy(batch->resources, NULL);
+        panfrost_batch_destroy_resources(ctx, batch);
         panfrost_pool_cleanup(&batch->pool);
         panfrost_pool_cleanup(&batch->invisible_pool);
 
@@ -239,17 +294,8 @@ panfrost_batch_update_access(struct panfrost_batch *batch,
         uint32_t batch_idx = panfrost_batch_idx(batch);
         struct hash_entry *entry = _mesa_hash_table_search(ctx->writers, rsrc);
         struct panfrost_batch *writer = entry ? entry->data : NULL;
-        bool found = false;
 
-        _mesa_set_search_or_add(batch->resources, rsrc, &found);
-
-        if (!found) {
-                /* Cache number of batches accessing a resource */
-                rsrc->track.nr_users++;
-
-                /* Reference the resource on the batch */
-                pipe_reference(NULL, &rsrc->base.reference);
-        }
+        panfrost_batch_add_resource(batch, rsrc);
 
         /* Flush users if required */
         if (writes || ((writer != NULL) && (writer != batch))) {
@@ -262,7 +308,7 @@ panfrost_batch_update_access(struct panfrost_batch *batch,
                                 continue;
 
                         /* Submit if it's a user */
-                        if (_mesa_set_search(batch->resources, rsrc))
+                        if (panfrost_batch_uses_resource(batch, rsrc))
                                 panfrost_batch_submit(ctx, batch);
                 }
         }
@@ -363,30 +409,14 @@ panfrost_resource_swap_bo(struct panfrost_context *ctx,
                           struct panfrost_resource *rsrc,
                           struct panfrost_bo *newbo)
 {
-        /* Any batch writing this resource is writing to the old BO, not the
-         * new BO. After swapping the resource's backing BO, there will be no
-         * writers of the updated resource. Existing writers still hold a
-         * reference to the old BO for reference counting.
-         */
-        struct hash_entry *writer = _mesa_hash_table_search(ctx->writers, rsrc);
-        if (writer) {
-                _mesa_hash_table_remove(ctx->writers, writer);
-                rsrc->track.nr_writers--;
-        }
-
         /* Likewise, any batch reading this resource is reading the old BO, and
          * after swapping will not be reading this resource.
          */
         unsigned i;
         foreach_batch(ctx, i) {
                 struct panfrost_batch *batch = &ctx->batches.slots[i];
-                struct set_entry *ent = _mesa_set_search(batch->resources, rsrc);
-
-                if (!ent)
-                        continue;
 
-                _mesa_set_remove(batch->resources, ent);
-                rsrc->track.nr_users--;
+                panfrost_batch_remove_resource_if_present(ctx, batch, rsrc);
         }
 
         /* Swap the pointers, dropping a reference to the old BO which is no
@@ -891,7 +921,7 @@ panfrost_flush_batches_accessing_rsrc(struct panfrost_context *ctx,
         foreach_batch(ctx, i) {
                 struct panfrost_batch *batch = &ctx->batches.slots[i];
 
-                if (!_mesa_set_search(batch->resources, rsrc))
+                if (!panfrost_batch_uses_resource(batch, rsrc))
                         continue;
 
                 perf_debug_ctx(ctx, "Flushing user due to: %s", reason);
diff --git a/src/gallium/drivers/panfrost/pan_job.h b/src/gallium/drivers/panfrost/pan_job.h
index 52eac4e0b17f..23263c54e071 100644
--- a/src/gallium/drivers/panfrost/pan_job.h
+++ b/src/gallium/drivers/panfrost/pan_job.h
@@ -192,7 +192,7 @@ struct panfrost_batch {
         struct pan_tristate sprite_coord_origin;
         struct pan_tristate first_provoking_vertex;
 
-        /* Referenced resources */
+        /* Referenced resources, holds a pipe_reference. */
         struct set *resources;
 };
 
-- 
GitLab


From f302ab24542b99c7b36be7ae35b4253d3c65ea21 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@collabora.com>
Date: Sat, 29 Oct 2022 15:45:03 -0400
Subject: [PATCH 02/14] pan/mdg: Fix out-of-order execution

We can go up to 15 instructions out of order (performance fix) but we
can't go past a branch (bug fix).

Fixes: 30a393f4581 ("pan/mdg: Enable out-of-order execution after texture ops")
Signed-off-by: Alyssa Rosenzweig <alyssa@collabora.com>
---
 src/panfrost/midgard/midgard.h      |  4 ++--
 src/panfrost/midgard/midgard_emit.c | 16 ++++++++++------
 2 files changed, 12 insertions(+), 8 deletions(-)

diff --git a/src/panfrost/midgard/midgard.h b/src/panfrost/midgard/midgard.h
index d7715c697cd6..2121dc4790b7 100644
--- a/src/panfrost/midgard/midgard.h
+++ b/src/panfrost/midgard/midgard.h
@@ -937,8 +937,8 @@ __attribute__((__packed__))
          * be any dependency (the blob appears to forbid even accessing other
          * channels of a given texture register). */
 
-        unsigned out_of_order   : 2;
-        unsigned unknown4  : 10;
+        unsigned out_of_order   : 4;
+        unsigned unknown4  : 8;
 
         /* In immediate mode, each offset field is an immediate range [0, 7].
          *
diff --git a/src/panfrost/midgard/midgard_emit.c b/src/panfrost/midgard/midgard_emit.c
index 716e434b7bcb..52dd4a85968f 100644
--- a/src/panfrost/midgard/midgard_emit.c
+++ b/src/panfrost/midgard/midgard_emit.c
@@ -416,10 +416,11 @@ mir_pack_swizzle_tex(midgard_instruction *ins)
         /* TODO: bias component */
 }
 
-/* Up to 3 { ALU, LDST } bundles can execute in parallel with a texture op.
+/*
+ * Up to 15 { ALU, LDST } bundles can execute in parallel with a texture op.
  * Given a texture op, lookahead to see how many such bundles we can flag for
- * OoO execution */
-
+ * OoO execution
+ */
 static bool
 mir_can_run_ooo(midgard_block *block, midgard_bundle *bundle,
                 unsigned dependency)
@@ -432,11 +433,14 @@ mir_can_run_ooo(midgard_block *block, midgard_bundle *bundle,
         if (!IS_ALU(bundle->tag) && bundle->tag != TAG_LOAD_STORE_4)
                 return false;
 
-        /* Ensure there is no read-after-write dependency */
-
         for (unsigned i = 0; i < bundle->instruction_count; ++i) {
                 midgard_instruction *ins = bundle->instructions[i];
 
+                /* No branches, jumps, or discards */
+                if (ins->compact_branch)
+                        return false;
+
+                /* No read-after-write data dependencies */
                 mir_foreach_src(ins, s) {
                         if (ins->src[s] == dependency)
                                 return false;
@@ -452,7 +456,7 @@ mir_pack_tex_ooo(midgard_block *block, midgard_bundle *bundle, midgard_instructi
 {
         unsigned count = 0;
 
-        for (count = 0; count < 3; ++count) {
+        for (count = 0; count < 15; ++count) {
                 if (!mir_can_run_ooo(block, bundle + count + 1, ins->dest))
                         break;
         }
-- 
GitLab


From 1bbeb42d7df7d55a9c9647427bcbd7dcff0f1f54 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@collabora.com>
Date: Thu, 27 Oct 2022 22:15:24 -0400
Subject: [PATCH 03/14] pan/mdg: Refuse to schedule CSEL.vector to SMUL

Even if we only mask a single component from the result of CSEL.vector,
in our IR we treat its semantics as vector which causes trouble with
when scheduled to a scalar unit.

The problematic bundle looks like this:

   vmul.MOV.i32 R31, TMP0.xxxx, R0.yzww
   sadd.MAX.i32 TMP0.y, R0.y, #65408
   smul.CSEL.vector.i32 R0.y, TMP0.y, #127

As the comment in midgard.h illuminates, these CSEL instructions are
actually operating per-bit, lining up with the all-1's booleans in
Midgard. The Bifrost analogue is MUX.i32.bit, not CSEL.i32. We should
probably rename the Midgard instruction to make that clear.

Anyhoo, on the scalar unit, CSEL/MUX operates on the bottom 32-bits of
its source. That's ok for the usual r31.w case, because that's secretly
replicating to its nonexistent register, I think? But that doesn't work
with the CSEL.vector (MUX.vector) form, because the condition it's
actually muxing on is r31.x, which here is R0.y, not the intended R0.x.

Rather than adding more special cases to the already overcomplicated
scheduler (for the dubious benefit of avoiding a small shaderdb
regression), just avoid scheduling CSEL.vector to smul.

With the next patch, fixes:

dEQP-GLES31.functional.draw_buffers_indexed.random.max_required_draw_buffers.1

Signed-off-by: Alyssa Rosenzweig <alyssa@collabora.com>
---
 src/panfrost/midgard/midgard_ops.c | 14 +++++++++++---
 1 file changed, 11 insertions(+), 3 deletions(-)

diff --git a/src/panfrost/midgard/midgard_ops.c b/src/panfrost/midgard/midgard_ops.c
index 4e12a25064a5..e45949085990 100644
--- a/src/panfrost/midgard/midgard_ops.c
+++ b/src/panfrost/midgard/midgard_ops.c
@@ -113,10 +113,18 @@ struct mir_op_props alu_opcode_props[256] = {
         [midgard_alu_op_ult]             = {"CMP.lt", UNITS_MOST},
         [midgard_alu_op_ule]             = {"CMP.le", UNITS_MOST},
 
-        /* csel must run in the second pipeline stage (condition written in first) */
+        /* CSEL (MUX) runs in the second pipeline stage, sourcing its selector
+         * the previous scalar or vector stage as indicated in the opcode. It
+         * muxes individual bits based on the selector, implementing both
+         * bit_select and bcsel (the latter because CMP returns 0/~0 booleans).
+         *
+         * It is legal to schedule (F)CSEL.vector to the scalar unit, but it
+         * isn't usually useful. Our scheduler does not handle that case, so
+         * don't try to and fall over.
+         */
         [midgard_alu_op_icsel]           = {"CSEL.scalar", UNIT_VADD | UNIT_SMUL},
-        [midgard_alu_op_icsel_v]         = {"CSEL.vector", UNIT_VADD | UNIT_SMUL}, /* Acts as bitselect() */
-        [midgard_alu_op_fcsel_v]         = {"FCSEL.vector", UNIT_VADD | UNIT_SMUL},
+        [midgard_alu_op_icsel_v]         = {"CSEL.vector", UNIT_VADD},
+        [midgard_alu_op_fcsel_v]         = {"FCSEL.vector", UNIT_VADD},
         [midgard_alu_op_fcsel]           = {"FCSEL.scalar", UNIT_VADD | UNIT_SMUL},
 
         [midgard_alu_op_frcp]            = {"FRCP", UNIT_VLUT},
-- 
GitLab


From 9646abba3da78b7a693b4936dbd8e16a1deecf9e Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@collabora.com>
Date: Thu, 27 Oct 2022 21:28:34 -0400
Subject: [PATCH 04/14] pan/mdg: Emulate 8-bit with the 16-bit pipe

We don't care to support i8vec16, we just need a bit of 8-bit support to
implement format packing/unpacking in blend shaders. We're already doing
this by using the 16-bit pipe, we just need to commit to it all the way
-- reporting the correct sizes in max_bitsize_for_alu so the mask
packing logic works as intended -- and dropping the imov-specific hack
that was introduced to workaround a similar class of bugs.

With the previous patch, fixes:

   dEQP-GLES31.functional.draw_buffers_indexed.random.max_required_draw_buffers.1

Fixes: 39e4b7279dc ("pan/midg: Fix swizzling on 8-bit sources")
Signed-off-by: Alyssa Rosenzweig <alyssa@collabora.com>
---
 src/panfrost/ci/panfrost-t860-fails.txt |  4 ----
 src/panfrost/midgard/midgard_compile.c  |  3 +++
 src/panfrost/midgard/midgard_emit.c     |  6 ------
 src/panfrost/midgard/mir.c              | 14 +++++---------
 4 files changed, 8 insertions(+), 19 deletions(-)

diff --git a/src/panfrost/ci/panfrost-t860-fails.txt b/src/panfrost/ci/panfrost-t860-fails.txt
index 8190d9625406..9c1d19c67441 100644
--- a/src/panfrost/ci/panfrost-t860-fails.txt
+++ b/src/panfrost/ci/panfrost-t860-fails.txt
@@ -4,11 +4,9 @@ dEQP-GLES3.functional.draw_buffers_indexed.random.max_implementation_draw_buffer
 dEQP-GLES3.functional.draw_buffers_indexed.random.max_implementation_draw_buffers.3,Fail
 dEQP-GLES3.functional.draw_buffers_indexed.random.max_implementation_draw_buffers.4,Fail
 dEQP-GLES3.functional.draw_buffers_indexed.random.max_implementation_draw_buffers.5,Fail
-dEQP-GLES3.functional.draw_buffers_indexed.random.max_implementation_draw_buffers.7,Fail
 dEQP-GLES3.functional.draw_buffers_indexed.random.max_implementation_draw_buffers.8,Fail
 dEQP-GLES3.functional.draw_buffers_indexed.random.max_implementation_draw_buffers.9,Fail
 dEQP-GLES3.functional.draw_buffers_indexed.random.max_implementation_draw_buffers.10,Fail
-dEQP-GLES3.functional.draw_buffers_indexed.random.max_implementation_draw_buffers.11,Fail
 dEQP-GLES3.functional.draw_buffers_indexed.random.max_implementation_draw_buffers.12,Fail
 dEQP-GLES3.functional.draw_buffers_indexed.random.max_implementation_draw_buffers.13,Fail
 dEQP-GLES3.functional.draw_buffers_indexed.random.max_implementation_draw_buffers.14,Fail
@@ -17,7 +15,6 @@ dEQP-GLES3.functional.draw_buffers_indexed.random.max_implementation_draw_buffer
 dEQP-GLES3.functional.draw_buffers_indexed.random.max_implementation_draw_buffers.17,Fail
 dEQP-GLES3.functional.draw_buffers_indexed.random.max_implementation_draw_buffers.18,Fail
 dEQP-GLES3.functional.draw_buffers_indexed.random.max_implementation_draw_buffers.19,Fail
-dEQP-GLES3.functional.draw_buffers_indexed.random.max_required_draw_buffers.1,Fail
 dEQP-GLES3.functional.draw_buffers_indexed.random.max_required_draw_buffers.2,Fail
 dEQP-GLES3.functional.draw_buffers_indexed.random.max_required_draw_buffers.10,Fail
 dEQP-GLES3.functional.draw_buffers_indexed.random.max_required_draw_buffers.11,Fail
@@ -25,7 +22,6 @@ dEQP-GLES3.functional.draw_buffers_indexed.random.max_required_draw_buffers.12,F
 dEQP-GLES3.functional.draw_buffers_indexed.random.max_required_draw_buffers.15,Fail
 dEQP-GLES3.functional.draw_buffers_indexed.random.max_required_draw_buffers.16,Fail
 dEQP-GLES3.functional.draw_buffers_indexed.random.max_required_draw_buffers.17,Fail
-dEQP-GLES3.functional.draw_buffers_indexed.random.max_required_draw_buffers.18,Fail
 dEQP-GLES3.functional.fbo.blit.rect.nearest_consistency_mag,Fail
 dEQP-GLES3.functional.fbo.blit.rect.nearest_consistency_mag_reverse_dst_x,Fail
 dEQP-GLES3.functional.fbo.blit.rect.nearest_consistency_mag_reverse_dst_y,Fail
diff --git a/src/panfrost/midgard/midgard_compile.c b/src/panfrost/midgard/midgard_compile.c
index 940a98b75e0b..69d88eb4a601 100644
--- a/src/panfrost/midgard/midgard_compile.c
+++ b/src/panfrost/midgard/midgard_compile.c
@@ -2650,6 +2650,9 @@ max_bitsize_for_alu(midgard_instruction *ins)
         unsigned dst_bitsize = nir_alu_type_get_type_size(ins->dest_type);
         max_bitsize = MAX2(dst_bitsize, max_bitsize);
 
+        /* We emulate 8-bit as 16-bit for simplicity of packing */
+        max_bitsize = MAX2(max_bitsize, 16);
+
         /* We don't have fp16 LUTs, so we'll want to emit code like:
          *
          *      vlut.fsinr hr0, hr0
diff --git a/src/panfrost/midgard/midgard_emit.c b/src/panfrost/midgard/midgard_emit.c
index 52dd4a85968f..45b23db3f723 100644
--- a/src/panfrost/midgard/midgard_emit.c
+++ b/src/panfrost/midgard/midgard_emit.c
@@ -340,12 +340,6 @@ mir_pack_vector_srcs(midgard_instruction *ins, midgard_vector_alu *alu)
                 unsigned sz = nir_alu_type_get_type_size(ins->src_types[i]);
                 assert((sz == base_size) || (sz == base_size / 2));
 
-                /* Promote 8bit moves to 16bit ones so we can support any swizzles. */
-                if (sz == 8 && base_size == 8 && ins->op == midgard_alu_op_imov) {
-                        ins->outmod = midgard_outmod_keeplo;
-                        base_size = 16;
-                }
-
                 midgard_src_expand_mode expand_mode = midgard_src_passthrough;
                 unsigned swizzle = mir_pack_swizzle(ins->mask, ins->swizzle[i],
                                                     sz, base_size, channeled,
diff --git a/src/panfrost/midgard/mir.c b/src/panfrost/midgard/mir.c
index 5ff9469bcff9..a4ea28fcdc81 100644
--- a/src/panfrost/midgard/mir.c
+++ b/src/panfrost/midgard/mir.c
@@ -232,20 +232,16 @@ mir_set_bytemask(midgard_instruction *ins, uint16_t bytemask)
         ins->mask = mir_from_bytemask(bytemask, type_size);
 }
 
-/* Checks if we should use an upper destination override, rather than the lower
- * one in the IR. Returns zero if no, returns the bytes to shift otherwise */
-
+/*
+ * Checks if we should use an upper destination override, rather than the lower
+ * one in the IR. If yes, returns the bytes to shift by. If no, returns zero
+ * for a lower override and negative for no override.
+ */
 signed
 mir_upper_override(midgard_instruction *ins, unsigned inst_size)
 {
         unsigned type_size = nir_alu_type_get_type_size(ins->dest_type);
 
-        /* 8bit imovs are promoted to 16bit ones with .sext on the source and
-         * .keeplo on the destination to accomodate with non-identity swizzles.
-         */
-        if (ins->op == midgard_alu_op_imov && type_size == 8)
-                return 0;
-
         /* If the sizes are the same, there's nothing to override */
         if (type_size == inst_size)
                 return -1;
-- 
GitLab


From b1c9ee39d7334e08e76928a18a13b940c447cc27 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@collabora.com>
Date: Sat, 29 Oct 2022 15:38:26 -0400
Subject: [PATCH 05/14] panfrost: Enable AFBC of cube maps

Missed by mistake. This is not the same as 3D AFBC, it's just like a 2D
array. Noted in a supertuxkart pandecode.

Signed-off-by: Alyssa Rosenzweig <alyssa@collabora.com>
Cc: mesa-stable
---
 src/gallium/drivers/panfrost/pan_resource.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/panfrost/pan_resource.c b/src/gallium/drivers/panfrost/pan_resource.c
index 11209a9b0225..9e95b793391e 100644
--- a/src/gallium/drivers/panfrost/pan_resource.c
+++ b/src/gallium/drivers/panfrost/pan_resource.c
@@ -316,8 +316,10 @@ panfrost_should_afbc(struct panfrost_device *dev,
 
         switch (pres->base.target) {
         case PIPE_TEXTURE_2D:
-        case PIPE_TEXTURE_2D_ARRAY:
         case PIPE_TEXTURE_RECT:
+        case PIPE_TEXTURE_2D_ARRAY:
+        case PIPE_TEXTURE_CUBE:
+        case PIPE_TEXTURE_CUBE_ARRAY:
                 break;
 
         case PIPE_TEXTURE_3D:
-- 
GitLab


From bfbc68412e12f17e526b26444ca5e91a41c46047 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@collabora.com>
Date: Thu, 27 Oct 2022 17:31:08 -0400
Subject: [PATCH 06/14] panfrost: Enable AFBC of sRGB formats

AFBC of sRGB formats should just work. We just need to flip it on and enjoy
the improved performance.

In particular, this means that RGBA8 UNORM and RGBA8 sRGB UNORM are now
considered compatible formats for AFBC. That's a bug fix, because
GALLIUM_HUD use will act like a texture view between sRGB and linear
views. For FBOs, that will "just" result in a decompression, hurting
performance. For window system rendering with AFBC, that will cause an
assertion failure, as we cannot decompress SHARED resources.

Fixes: 789601a189e ("panfrost: Decompress for incompatible AFBC formats")
Signed-off-by: Alyssa Rosenzweig <alyssa@collabora.com>
---
 src/panfrost/lib/pan_afbc.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/src/panfrost/lib/pan_afbc.c b/src/panfrost/lib/pan_afbc.c
index bf655e7a2c29..96c16b7fc8a0 100644
--- a/src/panfrost/lib/pan_afbc.c
+++ b/src/panfrost/lib/pan_afbc.c
@@ -74,6 +74,13 @@
 enum pipe_format
 panfrost_afbc_format(unsigned arch, enum pipe_format format)
 {
+        /* sRGB does not change the pixel format itself, only the
+         * interpretation. The interpretation is handled by conversion hardware
+         * independent to the compression hardware, so we can compress sRGB
+         * formats by using the corresponding linear format.
+         */
+        format = util_format_linear(format);
+
         /* Don't allow swizzled formats on v7 */
         switch (format) {
         case PIPE_FORMAT_B8G8R8A8_UNORM:
-- 
GitLab


From 8dd0bb85789513b281e1edde1823f10e7f3f6f07 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@collabora.com>
Date: Sat, 29 Oct 2022 15:58:28 -0400
Subject: [PATCH 07/14] panfrost: Enable AFBC of more formats

Enable AFBC for all RGBA UNORM formats possible in v5. This does not
cover the AFBC rules for newer gens, nor for YUV.

Noticed with an uncompressed R8 UNORM texture in SuperTuxKart.

Signed-off-by: Alyssa Rosenzweig <alyssa@collabora.com>
---
 src/panfrost/lib/pan_afbc.c | 92 ++++++++++++++++++++++++-------------
 1 file changed, 59 insertions(+), 33 deletions(-)

diff --git a/src/panfrost/lib/pan_afbc.c b/src/panfrost/lib/pan_afbc.c
index 96c16b7fc8a0..7a524e53f668 100644
--- a/src/panfrost/lib/pan_afbc.c
+++ b/src/panfrost/lib/pan_afbc.c
@@ -66,6 +66,50 @@
  * generate a linear staging buffer and use the GPU to blit AFBC<--->linear.
  */
 
+static enum pipe_format
+unswizzled_format(enum pipe_format format)
+{
+        switch (format) {
+        case PIPE_FORMAT_A8_UNORM:
+        case PIPE_FORMAT_L8_UNORM:
+        case PIPE_FORMAT_I8_UNORM:
+                return PIPE_FORMAT_R8_UNORM;
+
+        case PIPE_FORMAT_L8A8_UNORM:
+                return PIPE_FORMAT_R8G8_UNORM;
+
+        case PIPE_FORMAT_B8G8R8_UNORM:
+                return PIPE_FORMAT_R8G8B8_UNORM;
+
+        case PIPE_FORMAT_R8G8B8X8_UNORM:
+        case PIPE_FORMAT_B8G8R8A8_UNORM:
+        case PIPE_FORMAT_B8G8R8X8_UNORM:
+        case PIPE_FORMAT_A8R8G8B8_UNORM:
+        case PIPE_FORMAT_X8R8G8B8_UNORM:
+        case PIPE_FORMAT_X8B8G8R8_UNORM:
+        case PIPE_FORMAT_A8B8G8R8_UNORM:
+                return PIPE_FORMAT_R8G8B8A8_UNORM;
+
+        case PIPE_FORMAT_B5G6R5_UNORM:
+                return PIPE_FORMAT_R5G6B5_UNORM;
+
+        case PIPE_FORMAT_B5G5R5A1_UNORM:
+                return PIPE_FORMAT_R5G5B5A1_UNORM;
+
+        case PIPE_FORMAT_R10G10B10X2_UNORM:
+        case PIPE_FORMAT_B10G10R10A2_UNORM:
+        case PIPE_FORMAT_B10G10R10X2_UNORM:
+                return PIPE_FORMAT_R10G10B10A2_UNORM;
+
+        case PIPE_FORMAT_A4B4G4R4_UNORM:
+        case PIPE_FORMAT_B4G4R4A4_UNORM:
+                return PIPE_FORMAT_R4G4B4A4_UNORM;
+
+        default:
+                return format;
+        }
+}
+
 /* AFBC supports compressing a few canonical formats. Additional formats are
  * available by using a canonical internal format. Given a PIPE format, find
  * the canonical AFBC internal format if it exists, or NONE if the format
@@ -81,50 +125,32 @@ panfrost_afbc_format(unsigned arch, enum pipe_format format)
          */
         format = util_format_linear(format);
 
-        /* Don't allow swizzled formats on v7 */
-        switch (format) {
-        case PIPE_FORMAT_B8G8R8A8_UNORM:
-        case PIPE_FORMAT_B8G8R8X8_UNORM:
-        case PIPE_FORMAT_A8R8G8B8_UNORM:
-        case PIPE_FORMAT_X8R8G8B8_UNORM:
-        case PIPE_FORMAT_X8B8G8R8_UNORM:
-        case PIPE_FORMAT_A8B8G8R8_UNORM:
-        case PIPE_FORMAT_B8G8R8_UNORM:
-        case PIPE_FORMAT_B5G6R5_UNORM:
-                if (arch >= 7)
-                        return PIPE_FORMAT_NONE;
+        /* Don't allow swizzled formats on v7+ */
+        if (arch >= 7 && format != unswizzled_format(format))
+                return PIPE_FORMAT_NONE;
 
-                break;
-        default:
-                break;
-        }
+        /* Otherwise swizzling doesn't affect AFBC */
+        format = unswizzled_format(format);
 
         switch (format) {
+        case PIPE_FORMAT_R8_UNORM:
+        case PIPE_FORMAT_R8G8_UNORM:
+        case PIPE_FORMAT_R8G8B8_UNORM:
+        case PIPE_FORMAT_R8G8B8A8_UNORM:
+        case PIPE_FORMAT_R5G6B5_UNORM:
+        case PIPE_FORMAT_R5G5B5A1_UNORM:
+        case PIPE_FORMAT_R10G10B10A2_UNORM:
+        case PIPE_FORMAT_R4G4B4A4_UNORM:
+                return format;
+
         case PIPE_FORMAT_Z16_UNORM:
                 return PIPE_FORMAT_R8G8_UNORM;
 
-        case PIPE_FORMAT_R8G8B8_UNORM:
-        case PIPE_FORMAT_B8G8R8_UNORM:
-                return PIPE_FORMAT_R8G8B8_UNORM;
-
-        case PIPE_FORMAT_R8G8B8A8_UNORM:
-        case PIPE_FORMAT_R8G8B8X8_UNORM:
         case PIPE_FORMAT_Z24_UNORM_S8_UINT:
         case PIPE_FORMAT_Z24X8_UNORM:
         case PIPE_FORMAT_X24S8_UINT:
-        case PIPE_FORMAT_B8G8R8A8_UNORM:
-        case PIPE_FORMAT_B8G8R8X8_UNORM:
-        case PIPE_FORMAT_A8R8G8B8_UNORM:
-        case PIPE_FORMAT_X8R8G8B8_UNORM:
-        case PIPE_FORMAT_X8B8G8R8_UNORM:
-        case PIPE_FORMAT_A8B8G8R8_UNORM:
                 return PIPE_FORMAT_R8G8B8A8_UNORM;
 
-        case PIPE_FORMAT_R5G6B5_UNORM:
-        case PIPE_FORMAT_B5G6R5_UNORM:
-                return PIPE_FORMAT_R5G6B5_UNORM;
-
-        /* TODO: More AFBC formats */
         default:
                 return PIPE_FORMAT_NONE;
         }
-- 
GitLab


From a6c80b8588c560e83814608505198f8e51a9ef45 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@collabora.com>
Date: Sun, 30 Oct 2022 21:24:34 -0400
Subject: [PATCH 08/14] panfrost: Use
 PIPE_CAP_VERTEX_ATTRIB_ELEMENT_ALIGNED_ONLY

..instead of 4BYTE_ALIGNED_ONLY. This is more correct and avoids
needless repacking. Noticed in Firefox, which was hitting the vbuf
translate path.

Fixes: e03622e50fc ("panfrost: Set STRIDE_4BYTE_ALIGNED_ONLY")
Signed-off-by: Alyssa Rosenzweig <alyssa@collabora.com>
---
 src/gallium/drivers/panfrost/pan_screen.c | 12 ++++++++++--
 1 file changed, 10 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_screen.c b/src/gallium/drivers/panfrost/pan_screen.c
index f0ecae940bb0..a3855f9302e3 100644
--- a/src/gallium/drivers/panfrost/pan_screen.c
+++ b/src/gallium/drivers/panfrost/pan_screen.c
@@ -210,8 +210,16 @@ panfrost_get_param(struct pipe_screen *screen, enum pipe_cap param)
         case PIPE_CAP_QUERY_TIMESTAMP:
                 return is_gl3;
 
-        /* TODO: Where does this req come from in practice? */
-        case PIPE_CAP_VERTEX_BUFFER_STRIDE_4BYTE_ALIGNED_ONLY:
+        /* The hardware requires element alignment for data conversion to work
+         * as expected. If data conversion is not required, this restriction is
+         * lifted on Midgard at a performance penalty. We conservatively
+         * require element alignment for vertex buffers, using u_vbuf to
+         * translate to match the hardware requirement.
+         *
+         * This is less heavy-handed than the 4BYTE_ALIGNED_ONLY caps, which
+         * would needlessly require alignment even for 8-bit formats.
+         */
+        case PIPE_CAP_VERTEX_ATTRIB_ELEMENT_ALIGNED_ONLY:
                 return 1;
 
         case PIPE_CAP_MAX_TEXTURE_2D_SIZE:
-- 
GitLab


From a6f92f4e020060811e2df6596c5bd0aee39117a0 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@collabora.com>
Date: Sat, 29 Oct 2022 16:41:05 -0400
Subject: [PATCH 09/14] panfrost: Don't set job_barrier on vertex jobs

This was a hack needed for the old transform feedback code. This barrier
is handled by the explicit XFB emulation that we're using on Midgard
now, so we don't need the barrier in the general case.

Signed-off-by: Alyssa Rosenzweig <alyssa@collabora.com>
---
 src/gallium/drivers/panfrost/pan_cmdstream.c | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_cmdstream.c b/src/gallium/drivers/panfrost/pan_cmdstream.c
index cd6a0641c1ee..e71d9754b1eb 100644
--- a/src/gallium/drivers/panfrost/pan_cmdstream.c
+++ b/src/gallium/drivers/panfrost/pan_cmdstream.c
@@ -2658,12 +2658,8 @@ panfrost_emit_vertex_tiler_jobs(struct panfrost_batch *batch,
 {
         struct panfrost_context *ctx = batch->ctx;
 
-        /* XXX - set job_barrier in case buffers get ping-ponged and we need to
-         * enforce ordering, this has a perf hit! See
-         * KHR-GLES31.core.vertex_attrib_binding.advanced-iterations
-         */
         unsigned vertex = panfrost_add_job(&batch->pool.base, &batch->scoreboard,
-                                           MALI_JOB_TYPE_VERTEX, true, false,
+                                           MALI_JOB_TYPE_VERTEX, false, false,
                                            ctx->indirect_draw ?
                                            batch->indirect_draw_job_id : 0,
                                            0, vertex_job, false);
-- 
GitLab


From 9aa03d2f7f049ebb3e42f9cfac3e3a0706d32e54 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@collabora.com>
Date: Sat, 29 Oct 2022 18:13:16 -0400
Subject: [PATCH 10/14] panfrost: Print perf debug when flushing everything

..Even if the only batch is the one that's currently bound.

Signed-off-by: Alyssa Rosenzweig <alyssa@collabora.com>
---
 src/gallium/drivers/panfrost/pan_job.c | 9 ++++-----
 1 file changed, 4 insertions(+), 5 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_job.c b/src/gallium/drivers/panfrost/pan_job.c
index 27be0ee10ed6..e4c9ddfc9537 100644
--- a/src/gallium/drivers/panfrost/pan_job.c
+++ b/src/gallium/drivers/panfrost/pan_job.c
@@ -886,16 +886,15 @@ out:
 void
 panfrost_flush_all_batches(struct panfrost_context *ctx, const char *reason)
 {
+        if (reason)
+                perf_debug_ctx(ctx, "Flushing everything due to: %s", reason);
+
         struct panfrost_batch *batch = panfrost_get_batch_for_fbo(ctx);
         panfrost_batch_submit(ctx, batch);
 
         for (unsigned i = 0; i < PAN_MAX_BATCHES; i++) {
-                if (ctx->batches.slots[i].seqnum) {
-                        if (reason)
-                                perf_debug_ctx(ctx, "Flushing everything due to: %s", reason);
-
+                if (ctx->batches.slots[i].seqnum)
                         panfrost_batch_submit(ctx, &ctx->batches.slots[i]);
-                }
         }
 }
 
-- 
GitLab


From e6c9a8b4779123ad9535e84a4e75132eec9303c2 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@collabora.com>
Date: Sat, 29 Oct 2022 18:16:22 -0400
Subject: [PATCH 11/14] panfrost: Add more perf warnings for flushes

These flushes were lurking.

Signed-off-by: Alyssa Rosenzweig <alyssa@collabora.com>
---
 src/gallium/drivers/panfrost/pan_job.c | 13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_job.c b/src/gallium/drivers/panfrost/pan_job.c
index e4c9ddfc9537..f95ca12fa262 100644
--- a/src/gallium/drivers/panfrost/pan_job.c
+++ b/src/gallium/drivers/panfrost/pan_job.c
@@ -229,8 +229,10 @@ panfrost_get_batch(struct panfrost_context *ctx,
         assert(batch);
 
         /* The selected slot is used, we need to flush the batch */
-        if (batch->seqnum)
+        if (batch->seqnum) {
+                perf_debug_ctx(ctx, "Flushing batch due to seqnum overflow");
                 panfrost_batch_submit(ctx, batch);
+        }
 
         panfrost_batch_init(ctx, key, batch);
 
@@ -308,8 +310,15 @@ panfrost_batch_update_access(struct panfrost_batch *batch,
                                 continue;
 
                         /* Submit if it's a user */
-                        if (panfrost_batch_uses_resource(batch, rsrc))
+                        if (panfrost_batch_uses_resource(batch, rsrc)) {
+                                perf_debug_ctx(ctx,
+                                               "Flushing %s %" PRIu64 " due to %s of %s",
+                                               writer == batch ? "writer" : "reader",
+                                               batch->seqnum,
+                                               writes ? "write" : "read",
+                                               rsrc->image.data.bo->label);
                                 panfrost_batch_submit(ctx, batch);
+                        }
                 }
         }
 
-- 
GitLab


From 838d80aefbc37ecc967d9090fb20df425e755619 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@collabora.com>
Date: Sun, 30 Oct 2022 21:37:51 -0400
Subject: [PATCH 12/14] panfrost: Don't round up polygon list BOs

Can waste large amounts of megabytes (11MB -> 16MB in one cases, wasting
5MB... which adds up across processes, especially on the 2GB machines.)

Signed-off-by: Alyssa Rosenzweig <alyssa@collabora.com>
---
 src/gallium/drivers/panfrost/pan_cmdstream.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/gallium/drivers/panfrost/pan_cmdstream.c b/src/gallium/drivers/panfrost/pan_cmdstream.c
index e71d9754b1eb..73cadbe98827 100644
--- a/src/gallium/drivers/panfrost/pan_cmdstream.c
+++ b/src/gallium/drivers/panfrost/pan_cmdstream.c
@@ -4754,7 +4754,6 @@ batch_get_polygon_list(struct panfrost_batch *batch)
                                                              batch->key.width,
                                                              batch->key.height,
                                                              has_draws);
-                size = util_next_power_of_two(size);
 
                 /* Create the BO as invisible if we can. If there are no draws,
                  * we need to write the polygon list manually because there's
-- 
GitLab


From aa630a38e6ef0b2bc998352a527afd5943d2a098 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@collabora.com>
Date: Sun, 30 Oct 2022 23:33:48 -0400
Subject: [PATCH 13/14] panfrost: Clean up tiler calculations

Signed-off-by: Alyssa Rosenzweig <alyssa@collabora.com>
---
 src/panfrost/lib/pan_tiler.c | 52 +++++++++---------------------------
 1 file changed, 12 insertions(+), 40 deletions(-)

diff --git a/src/panfrost/lib/pan_tiler.c b/src/panfrost/lib/pan_tiler.c
index e8bce5e2a609..72aad4dedc62 100644
--- a/src/panfrost/lib/pan_tiler.c
+++ b/src/panfrost/lib/pan_tiler.c
@@ -219,32 +219,6 @@
 /* Likewise, each tile per level has 512 bytes of body */
 #define FULL_BYTES_PER_TILE 0x200
 
-/* If the width-x-height framebuffer is divided into tile_size-x-tile_size
- * tiles, how many tiles are there? Rounding up in each direction. For the
- * special case of tile_size=16, this aligns with the usual Midgard count.
- * tile_size must be a power-of-two. Not really repeat code from AFBC/checksum,
- * because those care about the stride (not just the overall count) and only at
- * a a fixed-tile size (not any of a number of power-of-twos) */
-
-static unsigned
-pan_tile_count(unsigned width, unsigned height, unsigned tile_width, unsigned tile_height)
-{
-        unsigned aligned_width = ALIGN_POT(width, tile_width);
-        unsigned aligned_height = ALIGN_POT(height, tile_height);
-
-        unsigned tile_count_x = aligned_width / tile_width;
-        unsigned tile_count_y = aligned_height / tile_height;
-
-        return tile_count_x * tile_count_y;
-}
-
-/* For `masked_count` of the smallest tile sizes masked out, computes how the
- * size of the polygon list header. We iterate the tile sizes (16x16 through
- * 2048x2048). For each tile size, we figure out how many tiles there are at
- * this hierarchy level and therefore many bytes this level is, leaving us with
- * a byte count for each level. We then just sum up the byte counts across the
- * levels to find a byte count for all levels. */
-
 static unsigned
 panfrost_hierarchy_size(
                 unsigned width,
@@ -255,19 +229,16 @@ panfrost_hierarchy_size(
         unsigned size = PROLOGUE_SIZE;
 
         /* Iterate hierarchy levels */
+        u_foreach_bit(level, mask) {
+                assert(level <= (MAX_TILE_SHIFT - MIN_TILE_SHIFT) &&
+                       "invalid hierarchy mask");
 
-        for (unsigned b = 0; b < (MAX_TILE_SHIFT - MIN_TILE_SHIFT); ++b) {
-                /* Check if this level is enabled */
-                if (!(mask & (1 << b)))
-                        continue;
-
-                /* Shift from a level to a tile size */
-                unsigned tile_size = (1 << b) * MIN_TILE_SIZE;
+                /* Levels are power-of-two sizes */
+                unsigned tile_size = MIN_TILE_SIZE << level;
 
-                unsigned tile_count = pan_tile_count(width, height, tile_size, tile_size);
-                unsigned level_count = bytes_per_tile * tile_count;
-
-                size += level_count;
+                size += DIV_ROUND_UP(width, tile_size) *
+                        DIV_ROUND_UP(height, tile_size) *
+                        bytes_per_tile;
         }
 
         /* This size will be used as an offset, so ensure it's aligned */
@@ -287,12 +258,13 @@ static unsigned
 panfrost_flat_size(unsigned width, unsigned height, unsigned dim, unsigned bytes_per_tile)
 {
         /* First, extract the tile dimensions */
-
         unsigned tw = (1 << (dim & 0b111)) * 8;
         unsigned th = (1 << ((dim & (0b111 << 6)) >> 6)) * 8;
 
-        /* tile_count is ceil(W/w) * ceil(H/h) */
-        unsigned raw = pan_tile_count(width, height, tw, th) * bytes_per_tile;
+        /* Calculate the raw size */
+        unsigned raw = DIV_ROUND_UP(width, tw) *
+                       DIV_ROUND_UP(height, th) *
+                       bytes_per_tile;
 
         /* Round down and add offset */
         return 0x200 + ((raw / 0x200) * 0x200);
-- 
GitLab


From d8c24483d8a0cda964a4d33f1711175abe175e6f Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@collabora.com>
Date: Sun, 30 Oct 2022 23:34:13 -0400
Subject: [PATCH 14/14] panfrost: Heuristic to choose hier masks

Signed-off-by: Alyssa Rosenzweig <alyssa@collabora.com>
---
 src/gallium/drivers/panfrost/pan_cmdstream.c |  9 +++--
 src/panfrost/lib/pan_cs.c                    |  3 +-
 src/panfrost/lib/pan_cs.h                    |  6 ++++
 src/panfrost/lib/pan_encoder.h               |  6 ++--
 src/panfrost/lib/pan_tiler.c                 | 36 +++++++++++++++-----
 5 files changed, 45 insertions(+), 15 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_cmdstream.c b/src/gallium/drivers/panfrost/pan_cmdstream.c
index 73cadbe98827..18b53fb7477a 100644
--- a/src/gallium/drivers/panfrost/pan_cmdstream.c
+++ b/src/gallium/drivers/panfrost/pan_cmdstream.c
@@ -3667,6 +3667,9 @@ panfrost_direct_draw(struct panfrost_batch *batch,
 
         if (info->index_size && PAN_ARCH >= 9) {
                 indices = panfrost_get_index_buffer(batch, info, draw);
+
+                /* Use index count to estimate vertex count */
+                batch->tiler_ctx.vertex_count += draw->count;
         } else if (info->index_size) {
                 indices = panfrost_get_index_buffer_bounded(batch, info, draw,
                                                             &min_index,
@@ -3675,8 +3678,10 @@ panfrost_direct_draw(struct panfrost_batch *batch,
                 /* Use the corresponding values */
                 vertex_count = max_index - min_index + 1;
                 ctx->offset_start = min_index + draw->index_bias;
+                batch->tiler_ctx.vertex_count += vertex_count;
         } else {
                 ctx->offset_start = draw->start;
+                batch->tiler_ctx.vertex_count += vertex_count;
         }
 
         if (info->instance_count > 1) {
@@ -4748,12 +4753,12 @@ batch_get_polygon_list(struct panfrost_batch *batch)
         struct panfrost_device *dev = pan_device(batch->ctx->base.screen);
 
         if (!batch->tiler_ctx.midgard.polygon_list) {
-                bool has_draws = batch->scoreboard.first_tiler != NULL;
+                bool has_draws = !!batch->tiler_ctx.vertex_count;
                 unsigned size =
                         panfrost_tiler_get_polygon_list_size(dev,
                                                              batch->key.width,
                                                              batch->key.height,
-                                                             has_draws);
+                                                             batch->tiler_ctx.vertex_count);
 
                 /* Create the BO as invisible if we can. If there are no draws,
                  * we need to write the polygon list manually because there's
diff --git a/src/panfrost/lib/pan_cs.c b/src/panfrost/lib/pan_cs.c
index 7a62dcb3e0f8..07fca511da37 100644
--- a/src/panfrost/lib/pan_cs.c
+++ b/src/panfrost/lib/pan_cs.c
@@ -601,7 +601,8 @@ pan_emit_midgard_tiler(const struct panfrost_device *dev,
                         cfg.hierarchy_mask =
                                 panfrost_choose_hierarchy_mask(fb->width,
                                                                fb->height,
-                                                               1, hierarchy);
+                                                               tiler_ctx->vertex_count,
+                                                               hierarchy);
                         header_size = panfrost_tiler_header_size(fb->width,
                                                                  fb->height,
                                                                  cfg.hierarchy_mask,
diff --git a/src/panfrost/lib/pan_cs.h b/src/panfrost/lib/pan_cs.h
index 8186102e5c04..45f86be4c7f9 100644
--- a/src/panfrost/lib/pan_cs.h
+++ b/src/panfrost/lib/pan_cs.h
@@ -69,6 +69,12 @@ struct pan_fb_zs_attachment {
 };
 
 struct pan_tiler_context {
+        /* Sum of vertex counts (for non-indexed draws), index counts (for
+         * indexed draws on Valhall as a best effort), or ~0 if any indirect
+         * draws are used. Helps tune hierarchy masks.
+         */
+        uint64_t vertex_count;
+
         union {
                 mali_ptr bifrost;
                 struct {
diff --git a/src/panfrost/lib/pan_encoder.h b/src/panfrost/lib/pan_encoder.h
index 68349996cded..94d5b2f266fd 100644
--- a/src/panfrost/lib/pan_encoder.h
+++ b/src/panfrost/lib/pan_encoder.h
@@ -52,14 +52,14 @@ panfrost_choose_hierarchy_mask(
 static inline unsigned
 panfrost_tiler_get_polygon_list_size(const struct panfrost_device *dev,
                                      unsigned fb_width, unsigned fb_height,
-                                     bool has_draws)
+                                     unsigned vertex_count)
 {
-        if (!has_draws)
+        if (!vertex_count)
                 return MALI_MIDGARD_TILER_MINIMUM_HEADER_SIZE + 4;
 
         bool hierarchy = !dev->model->quirks.no_hierarchical_tiling;
         unsigned hierarchy_mask =
-                panfrost_choose_hierarchy_mask(fb_width, fb_height, 1, hierarchy);
+                panfrost_choose_hierarchy_mask(fb_width, fb_height, vertex_count, hierarchy);
 
         return panfrost_tiler_full_size(fb_width, fb_height, hierarchy_mask, hierarchy) +
                 panfrost_tiler_header_size(fb_width, fb_height, hierarchy_mask, hierarchy);
diff --git a/src/panfrost/lib/pan_tiler.c b/src/panfrost/lib/pan_tiler.c
index 72aad4dedc62..43533faef2cd 100644
--- a/src/panfrost/lib/pan_tiler.c
+++ b/src/panfrost/lib/pan_tiler.c
@@ -321,12 +321,6 @@ panfrost_choose_tile_size(
         return exp_w | (exp_h << 6);
 }
 
-/* In the future, a heuristic to choose a tiler hierarchy mask would go here.
- * At the moment, we just default to 0xFF, which enables all possible hierarchy
- * levels. Overall this yields good performance but presumably incurs a cost in
- * memory bandwidth / power consumption / etc, at least on smaller scenes that
- * don't really need all the smaller levels enabled */
-
 unsigned
 panfrost_choose_hierarchy_mask(
         unsigned width, unsigned height,
@@ -340,7 +334,31 @@ panfrost_choose_hierarchy_mask(
         if (!hierarchy)
                 return panfrost_choose_tile_size(width, height, vertex_count);
 
-        /* Otherwise, default everything on. TODO: Proper tests */
-
-        return 0xFF;
+        /* Heuristic: choose the largest minimum bin size such that there are
+         * an average of k vertices per bin at the lowest level. Model as:
+         *
+         * vertex_count / ((fb width / bin width) * (fb height / bin height)) = k
+         * bin size = sqrt(k (fb width) (fb height))
+         */
+        unsigned k = 4;
+
+        unsigned log2_min_bin_size =
+                util_logbase2_ceil((k * width * height) / vertex_count) / 2;
+
+        /* Do not use bins larger than the framebuffer. They will be empty. */
+        unsigned log2_max_bin_size = util_logbase2_ceil(MAX2(width, height));
+
+        /* Clamp to valid bin sizes */
+        log2_min_bin_size = CLAMP(log2_min_bin_size, MIN_TILE_SHIFT, MAX_TILE_SHIFT);
+        log2_max_bin_size = CLAMP(log2_max_bin_size, MIN_TILE_SHIFT, MAX_TILE_SHIFT);
+
+        /* Bin indices are numbered from 0 started with MIN_TILE_SIZE */
+        unsigned min_bin_index = log2_min_bin_size - MIN_TILE_SHIFT;
+        unsigned max_bin_index = log2_max_bin_size - MIN_TILE_SHIFT;
+
+        /* Enable up to 8 bins starting from the heuristic selected minimum. 8
+         * is the implementation specific maximum in supported Midgard devices.
+         */
+        return (BITFIELD_MASK(8) << min_bin_index) &
+                BITFIELD_MASK(max_bin_index + 1);
 }
-- 
GitLab

